# union(x, y)
* 합하기
* x가 속한 집합과 y가 속한 집합을 합친다. 즉, x와 y가 속한 두 집합을 합치는 연산
## 배열로 구현할 경우
* 배열의 모든 원소를 순회하면서 y의 집합 번호를 x의 집합 번호로 변경한다.
* 시간 복잡도: O(N)
##트리로 구현할 경우
* x, y의 루트 노드를 찾고 다르면 y를 x의 자손으로 넣어 두 트리를 합한다.
* 시간 복잡도: O(N)보다 작으므로 find 연산이 전체 수행 시간이 지배한다.

#find(x)
* 찾기
* x가 속한 집합의 대표값(루트 노드 값)을 반환한다. 즉, x가 어떤 집합에 속해 있는지 찾는 연산
##배열로 구현할 경우
* 한 번만에 x가 속한 집합 번호를 찾는다.
* 시간 복잡도: O(1)
##트리로 구현할 경우
* 노드의 집합 번호는 루트 노드이므로, 루트 노드를 확인하여 같은 집합인지 확인한다.
* 시간 복잡도: 트리의 높이와 시간 복잡도가 동일하다. (최악: O(N-1))



#find(x): 재귀 이용 
int find(int x) {
    // 루트 노드는 부모 노드 번호로 자기 자신을 가진다.
    if (root[x] == x) {
        return x;
    } else {
        // 각 노드의 부모 노드를 찾아 올라간다.
        return find(root[x]);
    }
}

#union(x, y)
void union(int x, int y){
    // 각 원소가 속한 트리의 루트 노드를 찾는다.
    x = find(x);
    y = find(y);

    root[y] = x;
}
https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html
